PANDA : 

import : df = pd.read('fichier')    # ou read_excel, read_parquet, etc.      
print(df.shape)                       # (nb_lignes, nb_colonnes)
print(df.columns)                     # noms des colonnes
print(df.head())                      # aperçu

print(df.dtypes)

RECUPERER DES LIGNES 


condition simple : adultes = df[df["age"] >= 18]
resultat = df[adultes]

filtre = (df["ville"] == "Paris") | (df["ville"] == "Lyon").   option + maj + L pour le : |
resultat = df[filtre]

res_nan = df[df["score"].isna()]
res_non_nan = df[df["score"].notna()]

pour récuperer uniquement quelques colones (plus propres avec le calcul)



res = df.loc[filtre, ["date", "pays", "score"]]
affichera que ces colonnes là tout en respectant le filtre


df_sorted = df.sort_values("date")  # ou "timestamp"
trie par cette colonnes


df_last = df.drop_duplicates(subset=["ville"], keep="last")
enleve les duplications et garde uniquement les dernieres


df["phi"] = df.apply(lambda row: test(row["a"], row["b"], row["c"]), axis=1) axis = 0 pour colonne et 1 pour ligne par ligne 
pour appliquer une fonction à des colonnes, lambda fonction anonyme évite d'en créé une nouvelle qui force le return 
pour chaque ligne du DataFrame, elle prend les 3 valeurs X/Vx, Y/Vy, Z/Vz,
 appelle xyz_to_pol(...), récupère le 1er élément [0], et le met dans la nouvelle colonne "lambda"



 '''
filtre_pos = (ITRF_2020['DATA_END'] == "00:000:00000") | ((ITRF_2020['DATA_END'].isna()) & (ITRF_2020['SITE NAME'].notna()) )
#je prends une condition sur data_end et les lignes en dessous qui correspond à la vitesse doivent être retirer : notna() enlèbe tout les NaN


last_version_position1 = ITRF_2020.loc[filtre_pos, ['SITE NAME', 'X/Vx','Y/Vy','Z/Vz'] ]
last_version_position1 = last_version_position1.drop_duplicates(subset = 'SITE NAME', keep = 'first')
'''